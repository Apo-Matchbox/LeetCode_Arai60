###Step1

82. [Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/)

83の類似問題。重複するnodeは選択せず(全て削除)、一度だけ出現する値を出力。

前提の確認 
- 昇順でソート済み、重複は隣接
- よって一回のループで処理可能
- 重複値があった場合、その値に該当する全てのコードを削除

出題意図
- Linked List　の操作（ノードの挿入・削除）
- ポインタの移動

解答欄に与えられたもの
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        
    }
};

ここからの対応が出来なかったので、
https://github.com/kazukiii/leetcode/pull/5/commits/35138cabcbc5f6091db9482943ee3f0c6a138e18　さんの解答を参考に練習。

```cpp
class Solution {
 public:
  ListNode* deleteDuplicates(ListNode* head) {
    ListNode dummy(0, head);
    ListNode* node = &dummy;
    ListNode* next_node = head;
    while (node && next_node) {
      bool has_duplicates = next_node->next && next_node->val == next_node->next->val;
        if (has_duplicates) {
          while (next_node->next && next_node->val == next_node->next->val) {
            node->next = next_node->next;
            next_node = next_node->next;
          }
            node->next = next_node->next;
            next_node = node->next;
            continue;
        }
        node = node->next;
        next_node = node->next;
    }
    return dummy.next;
 }
};

```

//ダミーの役割を理解するのに時間がかかった。一つずつの挙動の確認。

###Step2

83. で指摘のコメントがあったが、deleteがないため、リークに注意が必要
LeetCodeでは解放不要ですが、deleteを意識したものへ変更。

```cpp
class Solution {
 public:
   ListNode* deleteDuplicates(ListNode* head) {
     ListNode dummy(0, head);
     ListNode* node = &dummy;
     ListNode* next_node = head;

     while (node && next_node) {
       bool has_duplicates = next_node->next && next_node->val == next_node->next->val;

       if (has_duplicates) {
         int dup_val = next_node->val; // 重複部分をすべて delete
         while (next_node && next_node->val == dup_val) {
           ListNode* temp = next_node;
           next_node = next_node->next;
           delete temp;
         }
         node->next = next_node; // 重複をスキップ
       }
       else {
         node = next_node;
         next_node = next_node->next;
       }
     }
     return dummy.next;
   }
};

```

他の方のGitHubを確認
＊https://github.com/maeken4/Arai60/pull/4/commits/32508ad2702b7c64d55f45023bfd816fa33358c3
　maeken さん　
　野田さんのコメント：std::unique_ptr や std::shared_ptr の使い方を確認：https://cpprefjp.github.io/reference/memory/unique_ptr.html

* https://github.com/kazukiii/leetcode/pull/5/commits/6f0b47e756e954af07f99dad8a37c3d99c8ef65a
野田さんのコメント：early return したほうが読みやすくなると思います。

```cpp
if (curr->val == curr->next->val) {
    curr->next = curr->next->next;
    skip_count++;
    continue;
}

if (skip_count == 0) {
    prev = curr;
} else {
    prev->next = curr->next;
}

skip_count = 0;
curr = curr->next; 
```

###Step3
繰り返し    

【感想】
理解するのに時間がかかった。
ネストが深くなると読みづらくなるので、early return をした書き方の練習。
