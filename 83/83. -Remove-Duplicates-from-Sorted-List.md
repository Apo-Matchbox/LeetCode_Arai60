Step1: 
問題の意図として、Linked Listの引き継ぎ（削除）ができることを示すと考えた。
要素の削除は、連結リストだとO(1)、双方向連結リストを用いる方が簡単など。
同じ値がでたときにeraseで削除などで解決できるのではと考えた。
ただ、コードを書くことはできず、

```cpp

class Solution {
   public:
       ListNode *deleteDuplicates(ListNode *head) {
           ListNode* node = head;};

```

ここまでの完成となった。

Step2: 
削除に注目してしまっていたけど、「重複しないようリストの形を整える(unipue化)」焦点
*リストはすでに昇順にソートさせているので、同じ値が隣り合う。
*連接する重複ノードをスキップするように繋ぎ直す（remove）

*https://github.com/maeken4/Arai60/pull/3/commits/0df0aa780424fc413db0f486d4aee3b3bc3e3c88
  野田さんのコメント： *memory-leak に気をつける。物理メモリを使い切ると、スワップアウトが発生し、処理速度が遅くなる。最終的にスワップメモリも使い切ると異常終了します。
  野田さんのコメント： *また、業務のコードでは、 unique_ptr や shared_ptr といったスマートポインターの利用を検討することをお勧めいたします。
  Smart Pointer: https://google.github.io/styleguide/cppguide.html#Ownership_and_Smart_Pointers

*https://github.com/mptommy/coding-practice/pull/3/commits/86a9e8af06be39c62137aa3ebadcbd8ea501cb17
  *書き方の選択肢が多くてすごい。いくつかの書き方を思い浮かべながら、いずれが良いか選択をする。
  *読む努力をしたが、理解するのに数時間かかった。step3はまだ見てない。
  

```cpp

#include <iostream>

struct ListNode {
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
    public:
        ListNode *deleteDuplicates(ListNode *head) {
            ListNode* node = head;
            while (node != nullptr && node->next != nullptr) {
                if (node->val == node->next->val) {
                    ListNode* duplicate = node->next;
                    node->next = node->next->next;
                    delete duplicate;
                }
                else {
                    node = node->next;
                }
            }
            return head;
        }
};

```
Step3:
インデント、タブ、そしてスペースの使い分
https://google.github.io/styleguide/cppguide.html#Function_Declarations_and_Definitions
以降使い方に気をつける。
