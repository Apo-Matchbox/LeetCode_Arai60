# [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)

## Step1　
### 問題意図の考察
- 片方向連結リストの処理
- スタック

### 解法を考える
- LIFO で最後に入れた要素から取り出す。
- 全てのnodeをstd::stack<ListNode*>に積む。
- ダミーノード作成
- 逆順で連結
- 閉じる
- 新しい先頭に返す

### コメント
- これまで学習したLinked Listの問題とCSZAPで学習したstackの知識で初めて解くことができた。ただ、解けるようになる事にあまり意味はなく、あらゆる選択肢を手札として持ち正しい判断ができることが目的なので、その幅を広げていきたい。
- CSZAPで体系的に学んだことが、どういう挙動となるか意識することができた。問題を通して学ぶこともできるが、体系的に全体感と詳細を学ぶ事により時間をかけていきたい。インプット＆アウトプットの割合。
- 計算量などはあまり意識できなかったので、ここは課題。

```cpp
class Solution {
public:
  ListNode* reverseList(ListNode* head) {
    if (head == nullptr) {
      return head;
    }
    ListNode* node = head;
    std::stack<ListNode*> nodes;
    while (node != nullptr) {
      nodes.push(node);
      node = node->next;
    }
    ListNode reverse_node = ListNode();
    node = &reverse_node;
    while (!nodes.empty()) {
      node->next = nodes.top();
      nodes.pop();
      node = node->next;
    }
    node->next = nullptr;
    return reverse_node.next;
  }
};

```

## Step2

```cpp
    while (node != nullptr)

```
while (node)と記載していたが、pointerを条件式で使用すると、boolへ変換される。e.g. nullptr->false、非nullptr->true
可読性という点で、while (node) だとbool? int? と一瞬考えると感じ、上記の書き方のまま採用した。参考：https://google.github.io/styleguide/cppguide.html#Boolean_Expressions
短い方がいいか、どっちがいいだろう。

- https://github.com/Ryotaro25/leetcode_first60/blob/main/206.ReverseLinkedList/step6.cpp
 -> 上記の考えを考慮しないなら、こういう書き方もできる。
  ```cpp
  if (!head) {
    return nullptr;
  }
  
  ```

- ポインタの反転版 (走査しながら リンクの向きを1本ずつ逆向きに付け替えるだけ)という考え方もある。
  -> stackを使わないという点では、この問題意図とは異なるが、一つの例として。

```cpp
class Solution {
 public:
  ListNode* reverseList(ListNode* head) {
    ListNode* previous_node = nullptr;  
    ListNode* node = head;

    while (node != nullptr) {
      ListNode* next = node->next; 
      node->next = previous_node;
      previous_node = node;
      node = next;
    }
    return previous_node;
  }
};

```

## Step3
20min
